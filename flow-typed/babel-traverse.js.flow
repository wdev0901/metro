/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 * @format
 */

'use strict';

declare module '@babel/traverse' {
  declare export type Scope = {
    [key: string]: any,
  };

  declare export type TraversalContext = {
    [key: string]: any,
  };

  declare function getNodePathType(node: BabelNode): NodePath<BabelNode>;
  declare function getNodePathType(
    nodes: Array<BabelNode>,
  ): Array<NodePath<BabelNode>>;

  declare export class NodePath<+TNode: BabelNode = BabelNode> {
    /* Declaring node as readonly isn't entirely correct since the node can be
     * changed by e.g. calling replaceWith. However, this is needed to reasonably
     * work with `NodePath`, e.g. that passing `NodePath<CallExpression>` to a
     * `NodePath<Node> works.
     */
    +node: TNode;
    +parent: BabelNode;
    +parentPath: NodePath<>;
    key: string | number;
    parentKey: string;
    scope: Scope;

    get<TKey: $Keys<TNode>>(
      key: TKey,
      context?: boolean | TraversalContext,
    ): $Call<typeof getNodePathType, $ElementType<TNode, TKey>>;
    get(
      key: string,
      context?: boolean | TraversalContext,
    ): NodePath<> | Array<NodePath<>>;
    buildCodeFrameError<TError: Error>(
      msg: string,
      Error?: Class<TError>,
    ): TError;

    traverse(visitor: Object, state: any): void;

    skip(): void;
    remove(): void;
    insertBefore(node: BabelNode | Array<BabelNode>): any;
    /** Replace the current node with another. */
    replaceWith(replacement: BabelNode | NodePath<>): void;
    isImport(opts?: Object): boolean;
    isStatement(opts?: Object): boolean;
    isReferencedIdentifier(opts?: Object): boolean;
    evaluate(): {confident: boolean, value: any};
  }

  declare export type VisitNodeFunction<TNode: BabelNode, TState> = (
    path: NodePath<TNode>,
    state: TState,
  ) => void;

  declare export interface VisitNodeObject<TNode: BabelNode, TState> {
    enter?: (path: NodePath<TNode>, state: TState) => void;
    exit?: (path: NodePath<TNode>, state: TState) => void;
  }

  declare export type VisitNode<TNode: BabelNode, TState> =
    | VisitNodeFunction<TNode, TState>
    | VisitNodeObject<TNode, TState>;

  declare export type Visitor<TState = void> = {
    Program?: VisitNode<BabelNodeProgram, TState>,
    Function?: VisitNode<BabelNodeFunction, TState>,
    Class?: VisitNode<BabelNodeClass, TState>,
    Identifier?: VisitNode<BabelNodeIdentifier, TState>,
    CallExpression?: VisitNode<BabelNodeCallExpression, TState>,
    AssignmentExpression?: VisitNode<BabelNodeAssignmentExpression, TState>,
    ArrowFunctionExpression?: VisitNode<
      BabelNodeArrowFunctionExpression,
      TState,
    >,
    ConditionalExpression?: VisitNode<BabelNodeConditionalExpression, TState>,
    FunctionDeclaration?: VisitNode<BabelNodeFunctionDeclaration, TState>,
    FunctionExpression?: VisitNode<BabelNodeFunctionExpression, TState>,
    IfStatement?: VisitNode<BabelNodeIfStatement, TState>,
    BinaryExpression?: VisitNode<BabelNodeBinaryExpression, TState>,
    LogicalExpression?: VisitNode<BabelNodeLogicalExpression, TState>,
    UnaryExpression?: VisitNode<BabelNodeUnaryExpression, TState>,
    MemberExpression?: VisitNode<BabelNodeMemberExpression, TState>,
    Scope?: VisitNode<BabelNodeScopable, TState>,
    ImportDeclaration?: VisitNode<BabelNodeImportDeclaration, TState>,
    ExportNamedDeclaration?: VisitNode<BabelNodeExportNamedDeclaration, TState>,
    ExportAllDeclaration?: VisitNode<BabelNodeExportAllDeclaration, TState>,
  };

  declare export default function traverse<TState>(
    ast: BabelNode | Array<BabelNode>,
    visitor: Object,
    scope?: ?Scope,
    state?: ?TState,
    parentPath?: ?NodePath<>,
  ): void;
}
